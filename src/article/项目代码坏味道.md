### 1.对象解构

对象取值时，如果值比较多，建议使用对象解构。

坏味道示例：

```
getHintNum().then((res) => {
    if (res.code == 0) {
     commit('HINT_NUM', {
      examine_num: res.data.examine_num || 0,
      copy_num: res.data.copy_num || 0,
      forward_num: res.data.forward_num || 0,
      into_site_equipment_num: res.data.into_site_equipment_num || 0,
      allocation_num: res.data.allocation_num || 0,
      into_site_num: res.data.into_site_num || 0,
      task_num: res.data.task_num || 0,
      assign_num: res.data.assign_num || 0,
      assess_num: res.data.assess_num || 0,
      compensate_task_num: res.data.compensate_task_num || 0,
      stock_task_num: res.data.stock_task_num || 0,
      transport_task_num: res.data.transport_task_num || 0,
      logistics_wait_cnt: res.data.logistics_wait_cnt || 0,
      examine_deny_num: res.data.examine_deny_num || 0,
     })
    }
  })
```



**优化后：**

```
getHintNum().then((res) => {
    if (res.code == 0) {
     let {
      examine_num = 0,
      copy_num = 0,
      forward_num = 0,
      into_site_equipment_num = 0,
      allocation_num = 0,
      into_site_num = 0,
      task_num = 0,
      assign_num = 0,
      assess_num = 0,
      compensate_task_num = 0,
      stock_task_num = 0,
      transport_task_num = 0,
      logistics_wait_cnt = 0,
      examine_deny_num = 0,
      clue_num = 0,
     } = res.data || {}


     commit('HINT_NUM', {
      examine_num,
      copy_num,
      forward_num,
      into_site_equipment_num,
      allocation_num,
      into_site_num,
      task_num,
      assign_num,
      assess_num,
      compensate_task_num,
      stock_task_num,
      transport_task_num,
      logistics_wait_cnt,
      examine_deny_num,
      clue_num,
     })
    }
   })
```



### 2.逻辑复用

当发现有重复代码时，可以考虑抽离方法来进行复用。

坏味道示例：


```
const handleFollowUp = async (item) => {
  const res = await Dialog.confirm({
   title: '提示',
   message: '确定跟进吗？',
  })
  console.log(res)
  if (res) {
   projectRepeat({ project: item.project })
    .then((res) => {
     let project_ids = res || []
     if (project_ids.length) {
      Dialog.confirm({
       title: '提示',
       message: '项目重复，是否将项目关联线索',
       beforeClose(action) {
        return new Promise((resolve) => {
         if (action === 'confirm') {
          try {
           clueFollow(item.id, {
            is_repeat: 1,
            project_ids: project_ids,
           }).then(() => {
            Toast.success('跟进成功')
            // 重置列表所有项
            setTimeout(() => {
             eventBus.emit('cluesLoad')
             eventBus.emit('cluesDetailLoad')
            }, 400)
            resolve(true)
           })
          } catch (error) {
           console.log(error)
           resolve(true)
          }
         } else {
          resolve(true)
         }
        })
       },
      })
     } else {
      Dialog.confirm({
       title: '提示',
       message: '确认是否跟进，跟进之后会自动创建项目',
       beforeClose(action) {
        return new Promise((resolve) => {
         if (action === 'confirm') {
          try {
           clueFollow(item.id, {
            is_repeat: 2,
            project_ids: project_ids,
           }).then(() => {
            Toast.success('跟进成功')
            // 重置列表所有项
            setTimeout(() => {
             eventBus.emit('cluesLoad')
             eventBus.emit('cluesDetailLoad')
            }, 400)
            resolve(true)
           })
          } catch (error) {
           console.log(error)
           resolve(true)
          }
         } else {
          resolve(true)
         }
        })
       },
      })
     }
    })
    .catch(() => {})
  }
 }
```




**优化后：**

```
const handleFollowUp = async (item, actionText = '跟进') => {
  projectRepeat({ project: item.project })
   .then((res) => {
    let project_ids = res || [],
     title = '提示',
     message = project_ids.length
      ? '项目重复，是否将项目关联线索'
      : `确认是否${actionText}，${actionText}之后会自动创建项目`,
     is_repeat = project_ids ? 1 : 2
    Dialog.confirm({
     title,
     message,
     closeOnClickOverlay: true,
     beforeClose(action) {
      return new Promise((resolve) => {
       if (action != 'confirm') return resolve(true)
       clueFollow(item.id, {
        is_repeat,
        project_ids: project_ids,
       })
        .then(() => {
         Toast.success('操作成功')
         // 重置列表所有项
         setTimeout(() => {
          eventBus.emit('cluesLoad')
          eventBus.emit('cluesDetailLoad')
         }, 400)
         resolve(true)
        })
        .catch(() => {
         resolve(false)
        })
      })
     },
    })
   })
   .catch(() => {})
 }
```



### 3.异步方法需要加try...catch

**优化后：**

```
async handleChange(item) {
   try {
    await clueAssign({
     id: item.clueId,
     user_admin_id: item.id,
    })
    Toast.success('操作成功')
   } catch (err) {
    console.log(err)
   }
  },
```



### 4.后端做接口数据过滤


坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586405-f560bd00-96c3-4ad3-81e9-f626436827a7.png)



前端做过滤，会导致翻页不稳定。


### 5.尽量减少数组循环


坏味道示例：

```
this.list = list.map((item) => {
    item.XId = `${item.parts_id}-${item.cargo_space_id}`
    if (this.defaultIds.includes(item.XId)) {
     this.defaultIds = this.defaultIds.filter((id) => id != item.XId)
     this.activeItem.push(item)
     item.isSelect = true
    } else {
     if (this.activeItem.some((part) => part.XId == item.XId)) {
      item.isSelect = true
     } else {
      item.isSelect = false
     }
    }
    return item
   })
```


**优化后：**


```
this.list = list.map((item) => {
    const XId = `${item.parts_id}-${item.cargo_space_id}-${
     item.spare_parts?.source_type || ''
    }`
    const index = this.defaultIds.indexOf(XId)
    const isSelect = index > -1
    if (index > -1) {
     this.defaultIds.splice(index, 1)
     this.activeItem.push(item)
    }
    item.XId = XId
    item.isSelect = isSelect
    return item
   })
```



### 6.代码需完善注释

状态相关，常量相关，特殊逻辑都应补充注释。

坏味道示例：

```
setLine(index) {
   setTimeout(() => {  // 需要补充注释，为啥要异步延时
    const ref = this.$refs.tabs[index].children[0]
    const len = ref.offsetLeft
    const width = ref.offsetWidth
    this.lineStyle = {
     width: width + 'px',
     transform: `translateX(${len}px)`,
    }
   }, 300)
  },
```

好味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586272-f59bc11c-4cb1-4794-85ee-5f598a9f538e.png)



### 7.表格规范

- 表格需要加索引，索引开始值为1，以当页为准，不累加翻页
- 表格项中带ID或单号的，不允许换行
- 跳转详情通过ID号跳转
- 如果有导出，需要支持精确导出



### 8.公共方法命名规范


坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586430-1cc6ace8-b48f-4e0f-a32c-a044519e3738.png)


公有方法，全局方法，应特殊命名，比如以$, _开头。


### 9.函数定义


坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586445-b6e61a5f-299b-4ea8-a6ba-469a65572695.png)



函数内部执行有分支，有中途退出的操作，应该放到函数顶部。




### 10. 多余的if判断

坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586458-09cf248e-4f29-4ba4-936c-684004e6a80f.png)


不需要写if判断，直接return返回判断值即可。




### 11. 表单规范

- 只有表单页才会有“返回”操作。其他页面不加
- 表单的提交需要二次确认




### 12.数据重复定义

坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586488-593f1522-44b5-4c0f-b66b-93ab105dc8fa.png)


原始数据只需定义一份，其他数据在原始数据上加工。




### 13.参数为对象，对象有利于扩展


坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586506-5bc64c16-d47c-4545-8fa8-4960a5a20131.png)



参数改用对象格式，不要传单个值，不利于将来扩展。




### 14.列表做翻页处理

坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586521-cbd079f1-f0d8-43ef-8b3c-ef2e840b8323.png)



不要出现翻页参数中每页数量很大的情况，尽量做翻页处理。




### 15.列表添加时的去重处理


坏味道示例：

![image](https://user-images.githubusercontent.com/5309877/180586540-cb784009-3835-49a9-91a6-57ae0a611491.png)


数组在进行合并时需要做去重处理。




### 16.文件命名规范




### 17.注释

- 删除注释的代码
- 注释的规范和格式
